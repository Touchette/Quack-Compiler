%top{
   /* Quack scanner
    *
    * 2018 Fall version for RE/flex,
    * skeleton, modified by Nate Letz
    *
    */

#include "quack.tab.hxx"  /* Generated by bison. */
#include "Messages.h"
%}

%{
   /* Externally visible file name --
    * for error messages.
    * FIXME: Need to extract this from structures that reflex passes
    * or else find another way to dig it out.
    */
std::string yyfilename = "lexing is hard";

   /* Some strings can't be matched in one gulp.  We need
    * a buffer in which to assemble them from parts.
    */
std::string string_buf = "";

void yyerror (const std::string &msg, yy::position* where) {
     std::cout << where << ": " << msg;
}

   /* Some long messages that don't fit well in the code below */

std::string BAD_ESC_MSG =
  "Illegal escape code; only \\\\, \\0, \\t, \\n, \\r, \\n are permitted";
std::string BAD_NL_STR =
  "Unclosed string?  Encountered newline in quoted string";

%}

%option bison-cc bison-locations noyywrap
%option namespace=yy lexer=Lexer lex=yylex

   /* You'll probably want scanner states for both multi-line
    * comments and for triple-quote strings.  Do comments first,
    * because they're easier (you just throw away the text).  Then
    * do triple-quote strings.  You might consider doing the same for
    * normal strings with a single pair of double quotes, to avoid
    * writing a really ugly regex.  'comment' here is an example of
    * how to declare an exclusive scanner state.
    */

%x COMMENT
%x STRING_LIT
%x TRIPLESTRING_LIT

%%

   /* We start with some tokens that are not value-bearing,
    * i.e., the parser needs to know only which token was matched.
    */

   /* Multi-character punctuation with names */
==    { return parser::token::EQUALS; }
[<]=  { return parser::token::ATMOST; }
[>]=  { return parser::token::ATLEAST; }

   /* Single character punctuation.  Because a character
    * in C or C++ can be treated as an integer, Bison lets
    * us return a character as a token.
    * JFlex/Cup do not let you do this in Java.
    * Here are a few ... there are more.
    */

[-+*/<>{}=(),;.:]  { return text()[0]; }

   /* Keywords are essentially another kind of punctuation,
    * but since they also match the identifier pattern, we
    * need to be sure we give their patterns *before* the
    * identifier pattern.  Most scanner generators work this
    * way, but WARNING for Python PLY users:  PLY prioritizes
    * by length of the regular expression!
    * Here are a couple of examples.
    */

typecase { return parser::token::TYPECASE; }
extends  { return parser::token::EXTENDS; }
return   { return parser::token::RETURN; }
class    { return parser::token::CLASS; }
while    { return parser::token::WHILE; }
elif     { return parser::token::ELIF; }
else     { return parser::token::ELSE; }
def      { return parser::token::DEF; }
and      { return parser::token::AND; }
not      { return parser::token::NOT; }
if       { return parser::token::IF; }
or       { return parser::token::OR; }

   /* The following tokens are value-bearing:
    * We pass a value back to the parser by copying
    * it into the yylval parameter.  The parser
    * expects string values for identifiers and
    * string literals in yylval.str.  It expects integer
    * values for integer literals in yylval.num.
    * I'll give pattern for integer literals.
    * You'll need another for identifiers.  Remember to
    * 'strdup' the value returned by 'text()', or else it will
    * be clobbered by subsequent calls.
    */

[0-9]+                 { yylval.num = atoi(text()); return parser::token::INT_LIT; }
[a-z_A-Z][a-z_A-Z0-9]* { yylval.str = strdup(text()); return parser::token::IDENT; }

   /* You *can* write a one-line regular expression for matching a quoted string,
    * but you probably can't read it.  (I can't read mine.)  Scanner states and
    * simpler patterns are probably a better idea.
    * You almost certainly scanner states for triple quotes.
    * The tricky bit is catching errors, such as disallowed escape sequences
    * and unclosed quotes.
    */

   /* Single-string literal */

\"                           { string_buf.clear(); start(STRING_LIT); }
<STRING_LIT> \"              { yylval.str = strdup(string_buf.c_str());
                               start(INITIAL);
                               return parser::token::STRING_LIT; }
<STRING_LIT> \\[^0brtnf\"\\] { report::error(BAD_ESC_MSG + ". At line: " + std::to_string(lineno())); }
<STRING_LIT> [\n]            { report::error(BAD_NL_STR + ". At line: " + std::to_string(lineno())); }
<STRING_LIT> \\\\            { string_buf.append(std::string("\\")); }
<STRING_LIT> \\\"            { string_buf.append(std::string("\"")); }
<STRING_LIT> \\0             { string_buf.append(std::string("\0")); }
<STRING_LIT> \\b             { string_buf.append(std::string("\b")); }
<STRING_LIT> \\r             { string_buf.append(std::string("\r")); }
<STRING_LIT> \\t             { string_buf.append(std::string("\t")); }
<STRING_LIT> \\n             { string_buf.append(std::string("\n")); }
<STRING_LIT> \\f             { string_buf.append(std::string("\f")); }
<STRING_LIT> .               { string_buf.append(std::string(text())); }

   /* Triple-string literal */

\"\"\"                       { string_buf.clear(); start(TRIPLESTRING_LIT); }
<TRIPLESTRING_LIT> \"\"\"    { yylval.str = strdup(string_buf.c_str());
                               start(INITIAL);
                               return parser::token::STRING_LIT; }
<TRIPLESTRING_LIT> [\r]      { string_buf.append("\r"); }
<TRIPLESTRING_LIT> [\t]      { string_buf.append("\t"); }
<TRIPLESTRING_LIT> [\n]      { string_buf.append("\n"); }
<TRIPLESTRING_LIT> .         { string_buf.append(text()); }

   /* Ignore whitespace */
[ \r\t\n]*       { ; }

   /* Single-line comments */
"//".*           { ; }

   /* Multi-line comments */
[/][*]           { start(COMMENT); }
<COMMENT>[^*]*   { ; }
<COMMENT>[*][^/] { ; }
<COMMENT>[*][/]  { start(INITIAL); }

.  { report::error("Unexpected character '" + std::string(text()) + "'" +
                   ". At line: " + std::to_string(lineno())); }

<<EOF>>  { return EOF; }

%%

  /* No main program here */
