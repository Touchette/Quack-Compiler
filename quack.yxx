/* Quack parser
 * Author: Nate Letz
 * Credit to Michal Young for skeleton
 */
%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }
}

%locations
/* %define parse.trace */

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */

}

%union {
    int   num;
    char* str;
	/* - */
	ASTNode::ASTNode *node;
}

/* -~-~-~- TOKENS -~-~-~- */
%token <str> STRING_LIT
%token <int> INT_LIT

%token WHILE RETURN TYPECASE
%token ATLEAST ATMOST EQUALS
%token CLASS DEF EXTENDS
%token IF ELIF ELSE
%token AND OR NOT
%token IDENT
%token NEG

/* -~-~-~- PRECEDENCE -~-~-~- */
%left '<' '>' EQUALS NOT ATLEAST ATMOST AND OR
%left '+' '-'
%left '*' '/' '.'
%left UMINUS

/* -~-~-~- AST NODES -~-~-~- */
%type <node> program

/* -~-~-~- GRAMMAR -~-~-~- */
%%

program
		: classes statements { }
		;

statements
		: statement statements { }
		| /* empty */
		;
methods
		: methods method { }
		| /* empty */
		;

classes
		: classes class { }
		| /* empty */
		;

class
		: class_signature class_body { }
		;

class_signature
		: CLASS ident '(' formal_args ')' { }
		| CLASS ident '(' formal_args ')' EXTENDS ident { }
		;

formal_args
		: ident ':' ident formal_args_extra { }
		| /* empty */
		;

formal_args_extra
		: formal_args_extra ',' ident ':' ident { }
		| /* empty */
		;

class_body
		: '{' statements methods '}' { }
		;

method
		: DEF ident '(' formal_args ')' statement_block { }
		| DEF ident '(' formal_args ')' ':' ident statement_block { }
		;

statement_block
		: '{' statements '}'
		;

statement
		: IF r_expr statement_block statement_elifs { }
		| IF r_expr statement_block statement_elifs ELSE statement_block { }
		| WHILE r_expr statement_block { }
		| l_expr '=' r_expr ';' { }
		| l_expr ':' ident '=' r_expr ';' { }
		| r_expr ';' { }
		| RETURN ';' { }
		| RETURN r_expr ';' { }
		| typecase { }
		;

statement_elifs
		: statement_elifs statement_elif { }
		| /* empty */
		;

statement_elif
		: ELIF r_expr statement_block { }

r_expr
		: STRING_LIT { }
		| INT_LIT { }
		| l_expr { }
		| r_expr OR r_expr { }
		| r_expr AND r_expr { }
		| r_expr ATMOST r_expr { }
		| r_expr ATLEAST r_expr {}
		| NOT r_expr { }
		| r_expr EQUALS r_expr { }
		| r_expr '>' r_expr { }
		| r_expr '<' r_expr { }
		| r_expr '+' r_expr { }
		| r_expr '-' r_expr { }
		| r_expr '/' r_expr { }
		| r_expr '*' r_expr { }
		| '(' r_expr ')' { }
		| r_expr '.' ident '(' actual_args ')' { }
		| ident '(' actual_args ')' { }
		;

l_expr
		: ident { }
		| r_expr '.' ident { }
		;

ident
		: IDENT { }
		;

actual_args
		: r_expr actual_args_extra { }
		| /* empty */
		;

actual_args_extra
		: actual_args_extra ',' r_expr { }
		| /* empty */
		;

typecase
		: TYPECASE r_expr '{' type_alternative '}' { }

type_alternative
		: ident ':' ident statement_block { }
		| /* empty */
		;

%%

/* -~-~-~- */

#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
    report::error_at(loc, msg);
}
