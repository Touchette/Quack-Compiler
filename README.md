# A Compiler for the Quack Language

This is a compiler written for Quack, a language developed by professor Michal Young at the University of Oregon. The lexer is written in C++ using the tool RE\Flex, the parser is written in C++ using the parser generator tool Bison, and the rest is written by hand.

## Lexer/Scanner ##
### quack.lxx ###

The lexer is written in RE\Flex: it tokenizes the Quack language appropriately for the parser to build a parse tree with. It matches patterns using regular expressions, the most complicated being string literals and comments. Other than that, it is pretty simple: regular expressions can match the patterns in Quack quite succinctly. An example regular expression for multi-line comments:

```c
   /* Multi-line comments */
[/][*]           { start(COMMENT); }
<COMMENT>[^*]*   { ; }
<COMMENT>[*][^/] { ; }
<COMMENT>[*][/]  { start(INITIAL); }
```

These regular expressions will, upon seeing `/*`, enter a so-called "scanner state" in which only the rules preceded by `<COMMENT>` are followed. When the scanner reads `[^*]*` (0 or more of anything that isn't an asterisk), it discards what it read (as a comment should do). When the scanner encounters `[*][^/]` (an asterisk followed by anything that is not /), it also throws it away, as the comment has not ended yet. Finally, upon finding `*/`, which closes a comment, the scanner returns to its initial start state with `start(INITIAL);`. 

## Parser ##
### quack.yxx, parser.cpp, names.h ###

The parser is written in Bison: it outlines the grammar of the Quack language and (hopefully) produces a parse tree that will be turned into the abstract syntax tree. It also outputs syntax errors when given programs do not conform to the grammar correctly and also notifies when a program is syntactically correct and well-structured. An example grammar rule/production for matching/parsing method calls:

```
method
    : DEF IDENT '(' formal_args ')' statement_block { }
    | DEF IDENT '(' formal_args ')' ':' IDENT statement_block { }
    ;
```

This production is entered from the following "hierarchy": program -> classes -> class -> methods -> method, where each of these is a non-terminal in the Quack grammar. Upon attempting to parse a method, this production will:
- Match a token `DEF`, which starts a method definition
- Match an identifier token `IDENT`, which is the name of the method
- Match an opening paren `'('`, which will contain the arguments to the function
- Match all the arguments to the method, the rules for which are contained in another non-terminal `formal_args`
- Match the closing paren `')'`
- Finally match the method statement `statement_block`, another non-terminal which will contain the actual code that the function executes

A similar pattern can be seen in the other option for a method call, wherein a `':'` (colon) is matched in order to serve as an initializer with another `IDENT` token. The parser also generates the Abstract Syntax Tree while parsing by building ASTNodes out of the information it finds. It does this with bison syntax by calling the ASTNode constructor with various types of information; such information comes in the form of bison references to the nonterminals and terminals, where `$$` is the nonterminal and `$n` is the nth terminal.

## Abstract Syntax Tree ##
### ASTEnum.h, ASTNode.h, ASTNode.cpp ###

The Abstract Syntax Tree (AST) that is generated by the parser. The AST is the representation of the program at its core with all useless information garnered from scanning tossed aside. If one wishes to generate the AST for any given Quack program, navigate to the "scripts" folder and use the `generateast.sh` script in the following way:

```bash
   user@host: .../Quack-Compiler/scripts$ ./genereateast.sh ../qcc samples/sample.qk
```

When generated, open the .png file output by the script to view the AST.

The AST is comprised of nodes, which are of type `AST::Node`. `AST::Node` is a generic type of tree node that is comprised of all information necessary to rebuild the type of statement that was parsed. For example, when the parser encounters an identifier, it creates a new node with type `IDENT`. This looks like the following call in `quack.yxx`, the bison file:

```
ident
        : IDENT { $$ = new AST::Node(IDENT, $1); }
        ;
```

All the various types of nodes can be found in `ASTEnum.h`, which also outlines some methods for turning a type into a string to be used by other methods. The AST also contains the information for printing the entire tree in json format which is how the pictures of it are generated.

## Type Checking ##
### typechecker.h, typechecker.cpp ###

Type checking consists of three different phases, a *class hierarchy check*, an *initialization before use check*, and a *type inference check*.

---

#### Class Hierarchy Check ####

The class hierarchy check is done to ensure that all classes have various different traits by checking that:
- Method compatibility between classes,
- Class definitions have no circular dependencies,
- All classes extend a super class that actually exists,
- If a class has already been defined,
- Finally, if a class method's definitions are compatible with its parents

The class hierarchy check does this primarily by utilizing a stack of the classes. It maintains super classes and seen classes, making the necessary checks against them in order to guarantee a correct program definition.

---

#### Initialization Before Use Check ####

The initialization before use check is performed to ensure that, on all possible paths of execution, all variables are initialized before they are used. An initialization *must* take the form `x: OptionalExplicitType = expression;`, otherwise it is treated as a `load` and is evaluated for location; this means that `x;` is illegal if `x` has not been initialized before. This check works in phases:
- For each class constructor, make sure that each variable is initialized on all paths before use:

   * All statements in the constructor are added to a vector with type `$UNKNOWN`
   * If a leaf boils down to an INTLITERAL, STRLITERAL, BOOLEAN, or NOTHING, then it is initialized
   * If not, it must be checked for a previous initialization
   
   * Compare all the instance variables in the constructor to its parent's by name, because all subclasses **must** define the instance variables that their parent class does.
- For each method within each class, make sure that all variables are initialized on all paths before use:

   * Check that each variable is initialized by form defined above
   * If a variable is of form `this.x`, then we must check that `this.x` is initialized in the constructor and is an instance variable of the current class (we can assume `this.x` is initialized because constructors are done before methods)
   * Perform the same checks as done in the constructor as they are still needed

---

#### Type Inference Check ####

This method is the most complicated part of type checking by far. It checks every type of node that we can find and performs a different type of check for each. For certain types of nodes, a recursive call is made that will re-infer the type of an "intermediary" statement that is part of a larger one. For example, `DOT` node types may be indefinitely long, such as in a statement like `he.she.him.her`. An example case where the node found is of type `LOAD`:

```c
	if (nodeType == LOAD) {
		if (stmt->get(IDENT) != NULL) { 
			std::string ident = stmt->get(IDENT)->name;
			if (ident == "this") {
				return method->clazz->name;
			} else if (ident == "true" || ident == "false") { 
				return "Boolean";
			} else if (ident == "none") {
				return "Nothing";
			} else {
				return method->type[ident];
			}
		} else {
			return typeInferStmt(method, stmt->rawChildren[0], changed, ret_flag);
		}
	}
```

This check will investigate a `LOAD` statement by use of various different checks:
- If the current `LOAD` node has an identifier associated with it, we can check for that directly, so:
   * If the identifier is equal to "this", then we return the name of the class that we are currently working in, because that's what this refers to
   * In the case of an identifier that is predefined such as "true", we can simply return the known type of that identifier
- Otherwise, we need to do a more complicated analysis involving the aforementioned recursive call:
   * We run typeInferStmt again on the first child of the `LOAD` node (as it ever only has one child we can use a hard-coded array access at index 0)
   * This method call will check against every type of node again, thus always ensuring that we get down to either another recursive call that will continue the chain, for example another `LOAD` node, or end at a node where the type is determined and the recursion makes its way back up with the inferred type.
   * This works for all method types as there must always be a return type at the end due to the leaves being identifiers

## Code Generation ##
### codegen.h, codegen.cpp ###

Code generation works by very similarly to the type inference method. Additionally, we must generate a lot of information pertaining to the classes themselves. The checklist for code generation is as follows:
- Generate the typedefs for all structs, this includes the object and class versions of each class,
- Generate the forward declarations necessary for each class, this includes method signatures in the case that they are used by a separate class,
- Generate the "extern" definitions for each class, and to be honest I'm not sure what they are. But I saw them in examples, so I put them here,
- Generate the actual structs for each class, this includes:
   * each class's "obj" struct which holds its class pointer as well as its instance variables and
   * each class's "class" struct which holds its super class pointer as well as inherited, overriden, and newly declared functions with their return types, names, and arguments. Each class's  constructor is defined alongside its class struct
- Generate the methods for each class,
   * this *does not* include inherited methods as they would be defined multiple times. Each method is generated along with its statements, and now *explicitly* takes the "this" pointer (this was not done in the quack method definition)
- Generate the "singletons" for every class, this pretty much ends up being a method table of how to get to each method call and includes inherited methods as well as a reference to the super class in order to use them

---

#### For generating actual statements ####

In order to generate the statements that go inside of methods, we must follow the same recursive model that typeInferStmt uses. Instead of checking type, however, we are now going to be printing out whatever information is associated with the node in question in C syntax: for example, a declaration in quack that takes the form of

```
x = 5;
```

would take the form of 

```c
obj_Int x;
obj_Int tempInt1 = int_literal(5);
x = (obj_Int) (tempInt18);
```

in the generated C code. The stark difference takes place because, in code generation, we make temporary storage variables for nearly everything. We can ensure that we always get the correct *dynamic* types this way, take the following quack code for example:

```
x = C4();
```

which generates the following C code:

```c
obj_C1 x;
obj_C4 tempVar6 = new_C4();
x = (obj_C1) (tempVar6);
```

Even though `x` is declared as a `C4`, we initialize it as its *dynamic* type `C1`. However, a new `C4` is then instantiated, and x is later set to its temporary variable and *casted* back to a `C1`. This allows us to always "line up" the methods of a class, allowing us to use dynamic method dispatch to always get the correct method call. The same happens for method calls, assignment statements, load statements, dot statements, etc.

---

Code generation for if statements, while loops, and boolean operators such as `and` all take a very different form in actual code generation. In more a more assembly-esque manner, if statements are generated like this:

```c
    obj_Int tempInt0 = int_literal(4);
    obj_Boolean tempResult1 = this->x->clazz->GREATER((obj_Int) this->x, (obj_Int) tempInt0);
    if (lit_true == tempResult1) { goto if2; }
    goto else2;
    // if statement true part!
    if2: 
        ; // Null statement
        obj_Int tempInt3 = int_literal(5);
        z = (obj_Int) (tempInt3);
    goto endif2;
    // if statement false part!
    else2: 
        ;	// Null statement
    goto endif2;
    endif2: 
        ; // Null statement
```

Here, we use "jumps" and comparisons to get around in an if statement. The boolean we are checking against is stored in a temporary variable and then checked against the "true" primitive, which in Quack is `lit_true`; this starts us on the journey to the assembly-esque statements. The `true` and `else` parts of the expression are generated as labels with their statements inside of them. We simply skip over the true part of the statement if the initial `if` check does not pass. While statements are generated in a similar manner, where the check against `lit_true` is at the bottom of the statement and sends us back up to a `loop_again` label in order to perform the statements again. 

---

# Installation and Use Guide #

## build.sh, clean.sh, CMakeLists.txt, invoke_gcc.sh ##

### Prerequisites to the Build Process ###

Please note that the compiler *does* have prerequisites in order to build properly. As the build process uses CMake, please install CMake before building. Furthermore, the scanner is written using RE\Flex, and the parser is written using bison. The link to Genivia's RE\Flex GitHub repository can be found here:

   https://github.com/Genivia/RE-flex

Where one can find their installation guide. **Note**: the CMakeLists.txt file that this build process uses assumes the following paths:

```
REFLEX_LIB : "/usr/local/lib/libreflex.a"
REFLEX_INCLUDE : "/usr/local/include/reflex"
```

So please ensure that RE\Flex can be found there. To install bison on Linux-based distributions, simply use your favorite package manager to install the package "bison". 

### Building ###

To install this compiler, simply clone the repository and run the following command:

```bash
   user@host: .../Quack-Compiler$ ./build.sh
```

To remove the build files, executables, and generated C files, run the following command: 

```bash
   user@host: .../Quack-Compiler$ ./clean.sh
```

### Using the Compiler and Its Resources ###

#### Actually Running the Compiler ####

To run the compiler executable, which is placed in the same directory where the `build` script was ran, use the following command (all compiler flags, beginning with `-`, are optional; there is a maximum of 2 flags at a time):

```bash
   user@host: .../Quack-Compiler$ ./qcc [filename] [-json] [-verbose] [-debug] [-ast]
```

##### Explanation of Compiler Flags #####

The `-json` flag will print the program's abstract syntax tree in JSON format to stdout.

The `-debug` flag will compile-stage start/completion messages. (I like to always use this flag for fun!)

The `-ast` will skip the initialization before use and type checking stages, allowing you to generate the AST image for an invalid program.

The `-verbose` will print program information such as the inferred types of variables and class information.

#### The Final Executable ####

The final outputted program will be called QuackOutput, so simply run

```bash
   user@host: .../Quack-Compiler$ ./QuackOutput
```

to execute the final program! The original .c file, named QuackOutput.c, is also available for investigation in the same directory, if one would like.

#### My Favorite Demo Programs ####

Found in the `favorite_samples` directory, here is a compilation of my favorite programs to run the compiler on, showing its various capabilities and range of functionality:

- `good_simple_inherited_method_printing.qk`, which shows off dynamic dispatch on executing an inherited method
- `good_Pt.qk`, which shows off dynamic dispatch by executing Obj's built-in PRINT method with Pt's overriden STR method
- `good_simple_if_and_short_circuit.qk`, which shows both if statements and short circuit evaluation
- `good_typecase.qk`, which shows off `typecase` working properly and working on all types of objects (builtins such as obj, nothing, int; user-defined classes)
- `good_control_flow.qk`, which shows off all types of control flow as well as printing based on which execution path was taken
- `good_the_kitchen_sink`, shows off most things in the language, uncomment things to see some fun errors
- `good_typewalk.qk`, shows off crawling up the class hierarchy to infer the right type for a method (known as abstract semantics)
- `bad_typewalk.qk`, same principle as good_typewalk.qk, but with a small error at the top of the class hierarchy that will be caught by the type inference check

### More Resources ###
#### generateast.sh, quack_compiler_testbench.sh, json_to_dot.py, all_tests.csv ####

**The generateast.sh script** 

Once you have have the compiled qcc binary, you can use the following command

```bash
   user@host: .../Quack-Compiler$ ./generateast.sh [path to qcc executable] [filename]
```

to automatically generate the AST image for the given quack program. The output file of this will be a `.png` image with the same name as the `.qk` file.

*note: json_to_dot.py must be in the same directory as the script for it to work.*

*another note: graphviz must be installed to use this script (it gives access to the "dot" command that is used).*

**The quack_compiler_testbench script**

This script was created by another student in the compilers course, Zayd Hammoudeh.

More information can be found on the repository managed by both him and professor Michal Young:

https://github.com/UO-cis561/quack-tests-static

---

## Final Comments ##

### Language Design Ambiguities ###

At a few points in developing the compiler, a decision needed to be made regarding what is allowed by the compiler with regards to ambiguities in the language design. This is a list of the decisions that were made (almost all of them in the type checking phase):

- Method and class arguments are treated as explicit declarations,
- Fields may not have the same name as a class or method,
- Methods may not have the same name as a class,
- Explicit `return` statement are disallowed in constructors,
- `this` cannot be passed as an argument in a constructor (as the object may not be completely initialized yet),
- Within a class, variables may not be assigned to `this`,
- The keyword "this" is disallowed inside of the main program statements,
- Dot operators (field access) cannot be used on a builtin class, eg; `"z".foo` or `2.bar`,
- Typecase variables that are introduced must not share a name with any existing variable in that scope,
- Dots of form `this.this` are prohibited

### Notes About Error Reporting ###

- If the method in which an error occurs has the same name of the class it is in, that means it occurred in the constructor. eg, "invalid type assigned to variable `x` in method `Classname()` in `class Classname()`",
- If an error occurs in either the method or class `$MAIN()`, that means the error occurred in the main statements area,
- Some errors may be reported more than once in type checking/inference
